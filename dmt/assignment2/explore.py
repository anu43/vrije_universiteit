#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Tue Apr 28 14:33:14 2020@author: anu"""from sklearn.linear_model import LogisticRegressionfrom sklearn.preprocessing import LabelEncoderimport matplotlib.pyplot as pltimport seaborn as snsimport pandas as pdimport numpy as np# Import training datadf = pd.read_csv('../../../../data/training_set_VU_DM.csv')# Convert date column to date_time typedf['date_time'] = pd.to_datetime(df['date_time'])# Define an empty list for columns to be deleteddropCols = list()def flatten(l):    '''    Flattens the multidimensional list to one dimensional    Parameters    ----------    l : list    Returns    -------    list        The flattened list.    '''    return [item for sublist in l for item in sublist]def list_missing_features_fraction(df):    '''    Prints the list of missing values in a given dataframe by descended sorting    Parameters    ----------    df : Pandas DataFrame object        The given dataset.    Returns    -------    None.    '''    # Get the percentage of missing values for each column    missing_frac = 1 - df.count() / len(df)    return missing_frac[missing_frac > 0.0].sort_values(ascending=False)def get_columns_names_has_missing(df):    '''    Returns the list of columns where the column has missing values    Parameters    ----------    df : Pandas DataFrame object        The given dataset.    Returns    -------    list        The list of columns where the column has missing values.    '''    return df.columns[df.isnull().any()].tolist()# Add another column which indicates the seasondef season(value):    '''    A lookup function for seasonal transformation    according to the time variable    Parameters    ----------    value : M8[ns]        Pandas date_time variable.    Returns    -------    str        related season.    '''    # Set seasonal ranges    spring = range(80, 172)    summer = range(172, 264)    fall = range(264, 355)        if value in spring:        return 'Spring'    if value in summer:        return 'Summer'    if value in fall:        return 'Fall'    else:        return 'Winter'# Set the new column seasondf['season'] = df.set_index('date_time').index.dayofyear.map(season)# Add date_time column to dropCols list to be deleted laterdropCols.append('date_time')# Create a dictionary for the mean customer review score by the id of the countriesavg_rev_scores = df.groupby(['prop_country_id'])['prop_review_score'].mean().to_dict()# Fill missing prop_review_score according to the id of the countrydf['prop_review_score'] = df.apply(    lambda row: avg_rev_scores[row['prop_country_id']] if np.isnan(row['prop_review_score']) else row['prop_review_score'],    axis=1)def is_child(row):    '''    An indicator to show whether it is a family vacation or not    Parameters    ----------    row : Pandas DataFrame object        Frame's row.    Returns    -------    int        A boolean value to indicate whether it is a family vacation.    '''    # If there is a child    if row['srch_children_count'] > 0:        # Set it as True        return 1    # False otherwise    return 0# Add additional column to indicate whether it is a family vacationdf['with_family'] = df.apply(is_child, axis=1)# Delete rows where price_usd feature is below 10df = df[df['price_usd'] > 10]def per_night(row):    '''    Calculates per night per room price if price_usd is higher than 150K.    Otherwise remains the same amount.    Parameters    ----------    row : Pandas DataFrame object        Frame's row.    Returns    -------    float        Returns the same or calculated new price.    '''    if row.price_usd > 150000:        if row.srch_children_count > 0:            person_count = row.srch_adults_count + row.srch_children_count * 0.5            return row.price_usd / (row.srch_length_of_stay * person_count)        else:            return row.price_usd / (row.srch_length_of_stay * row.srch_adults_count)    return row.price_usd# Create per night per room featuredf['per_night_per_room'] = df.apply(per_night, axis=1)# Add the following columns to dropCols list to be deleted laterdropCols.append([        'price_usd',        'srch_length_of_stay',        'srch_adults_count',        'srch_children_count'    ])# Deal with 'visitor_hist_starrating' and 'visitor_hist_adr_usd'# by inserting 0 for NaN values# Set lookup dictionary for fillingvisitor_hist_lookup = {    'visitor_hist_starrating': 0,    'visitor_hist_adr_usd': 0}# Fill according to the lookup dictionarydf = df.fillna(visitor_hist_lookup)# Add the columns which the very big fraction of their values are missingdropCols.append([        'comp1_rate',         'comp1_inv',         'comp1_rate_percent_diff',         'comp2_rate_percent_diff',         'comp3_rate_percent_diff',         'comp4_rate',         'comp4_inv',         'comp4_rate_percent_diff',         'comp5_rate_percent_diff',         'comp6_rate',         'comp6_inv',         'comp6_rate_percent_diff',         'comp7_rate',         'comp7_inv',         'comp7_rate_percent_diff',         'comp8_rate_percent_diff',         'gross_bookings_usd'    ])# Drop the columns in dropCols listdf = df.drop(dropCols, axis=1)# Generate correlation matrixcorr = df.corr()# Visualize the correlation matrixplt.figure(figsize=(20, 20))sns.heatmap(corr, annot=True, cmap="RdYlGn")# ----------------- FILLING MISSING VALUES -----------------# First deal with 'visitor_hist_starrating' and 'visitor_hist_adr_usd'# by inserting 0 for NaN values# Set lookup dictionary for fillingdFill = {    'visitor_hist_starrating': 0,    'visitor_hist_adr_usd': 0}# Fill according to the lookup dictionarydf = df.fillna(dFill)# Drop rows where 'prop_review_score' is NaNdf = df.dropna(subset=['prop_review_score'])# Define columns to drop and set to be as categoricalcols2Drop = ['date_time', 'srch_id', 'visitor_location_country_id', 'srch_destination_id']categoricalCols = ['site_id', 'visitor_hist_starrating', 'prop_country_id',                   'prop_id', 'prop_starrating', 'prop_review_score',                   'prop_brand_bool', 'position']# Copy dfdf_copy = df.copy()# Drop columns based on cols2Dropdf_copy = df_copy.drop(cols2Drop, axis=1)# Convert columns to categorical according to the categoricalColsfor col in categoricalCols:    df_copy[col] = df_copy[col].astype('category')# Apply Logistic Regression for predicting missing values of prop_location_score2# Create another df with NaN values version of df_copydf_notNaN = df_copy.dropna()# Before training, encode non-categorical featuresdf_notCategorical = df_notNaN.select_dtypes(    include=['float64', 'int64'])  # Non-categorical featuresX = df_notNaN.drop(['prop_location_score2'], axis=1).valuesy = LabelEncoder().fit_transform(df_notNaN['prop_location_score2'].values)clf = LogisticRegression(random_state=0).fit(X, y)# Predict the missing values of prop_location_score2X_predict = df_copy[df_copy.isnull().any(axis=1)].drop(['prop_location_score2'], axis=1)predictions = clf.predict()# ----------------- FILLING MISSING VALUES -----------------